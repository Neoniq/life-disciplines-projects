/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function escapeStringRegexp(string) {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
}

const INDENTED_LINE_PATTERN = new RegExp("^( {2,}|\\t)\\s*\\S+");
const COMPLETED_TASK_PATTERN = new RegExp("^(-|\\d+\\.) \\[x\\] ");
class Archiver {
    constructor(settings) {
        this.settings = settings;
        const escapedHeading = escapeStringRegexp(settings.archiveHeading);
        this.archivePattern = new RegExp(`^#+\\s+${escapedHeading}`);
        this.archiveEndPattern = new RegExp(`^#+\\s+(?!${escapedHeading})`);
    }
    archiveTasks(lines) {
        const hasArchive = lines.findIndex((line) => this.archivePattern.exec(line)) >= 0;
        if (!hasArchive) {
            if (lines[lines.length - 1].trim() !== "") {
                lines.push("");
            }
            lines.push(`# ${this.settings.archiveHeading}`);
        }
        const { linesWithoutArchive, archive } = this.extractArchive(lines);
        const { linesWithoutCompletedTasks, newlyCompletedTasks } = this.extractCompletedTasks(linesWithoutArchive);
        if (newlyCompletedTasks.length === 0) {
            return {
                summary: "No tasks to archive",
                lines: lines,
            };
        }
        const linesWithInsertedArchivedTasks = this.addTasksToArchive(newlyCompletedTasks, linesWithoutCompletedTasks, archive);
        return {
            summary: `Archived ${newlyCompletedTasks.length} lines`,
            lines: linesWithInsertedArchivedTasks,
        };
    }
    extractCompletedTasks(linesWithoutArchive) {
        const linesWithoutCompletedTasks = [];
        const newlyCompletedTasks = [];
        let linesAfterTask = false;
        for (const line of linesWithoutArchive) {
            if (line.match(COMPLETED_TASK_PATTERN)) {
                newlyCompletedTasks.push(line);
                linesAfterTask = true;
            }
            else if (line.match(INDENTED_LINE_PATTERN) && linesAfterTask) {
                newlyCompletedTasks.push(line);
            }
            else {
                linesWithoutCompletedTasks.push(line);
                linesAfterTask = false;
            }
        }
        return {
            linesWithoutCompletedTasks,
            newlyCompletedTasks,
        };
    }
    extractArchive(lines) {
        let archiveLines = [];
        let linesWithoutArchive = [];
        let insideArchive = false;
        for (const line of lines) {
            if (insideArchive) {
                if (this.archiveEndPattern.exec(line)) {
                    insideArchive = false;
                    linesWithoutArchive.push(line);
                }
                else if (line.trim().length > 0) {
                    archiveLines.push(line);
                }
            }
            else {
                if (this.archivePattern.exec(line)) {
                    insideArchive = true;
                }
                linesWithoutArchive.push(line);
            }
        }
        return {
            linesWithoutArchive,
            archive: new Archive(archiveLines, this.settings),
        };
    }
    addTasksToArchive(tasks, lines, archive) {
        const archiveWithNewTasks = archive.appendToContents(tasks);
        const archiveStart = lines.findIndex((l) => this.archivePattern.exec(l));
        lines.splice(archiveStart + 1, 0, ...archiveWithNewTasks);
        return lines;
    }
}
class Archive {
    constructor(lines, settings) {
        this.contents = lines;
        this.settings = settings;
    }
    appendToContents(newLines) {
        let insertionIndex;
        if (this.settings.useDateTree) {
            const week = window.moment().format(this.settings.weeklyNoteFormat);
            const indentationSettings = this.settings.indentationSettings;
            const indentation = indentationSettings.useTab
                ? "\t"
                : " ".repeat(indentationSettings.tabSize);
            newLines = newLines.map((line) => `${indentation}${line}`);
            const weekLine = `- [[${week}]]`;
            const currentWeekIndexInTree = this.contents.findIndex((line) => line.startsWith(weekLine));
            if (currentWeekIndexInTree < 0) {
                newLines.unshift(weekLine);
            }
            else {
                insertionIndex = this.findBlockEnd(weekLine);
            }
        }
        if (!insertionIndex) {
            insertionIndex = this.contents.length;
        }
        this.contents.splice(insertionIndex, 0, ...newLines);
        return ["", ...this.contents, ""];
    }
    findBlockEnd(parentLine) {
        let insideBlock = false;
        for (const [i, line] of this.contents.entries()) {
            if (line === parentLine) {
                insideBlock = true;
                continue;
            }
            const isLineIndented = INDENTED_LINE_PATTERN.exec(line);
            if (insideBlock && !isLineIndented) {
                return i;
            }
        }
        return this.contents.length;
    }
}

const DEFAULT_SETTINGS = {
    archiveHeading: "Archived",
    weeklyNoteFormat: "YYYY-MM-[W]-w",
    useDateTree: true,
    indentationSettings: {
        useTab: true,
        tabSize: 4,
    },
};
class ObsidianTaskArchiver extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.addCommand({
                id: "archive-tasks",
                name: "Archive tasks in this file",
                callback: () => this.archiveTasksInCurrentFile(),
            });
            yield this.loadSettings();
            this.addSettingTab(new ArchiverSettingTab(this.app, this));
        });
    }
    archiveTasksInCurrentFile() {
        return __awaiter(this, void 0, void 0, function* () {
            const activeFile = this.app.workspace.getActiveFile();
            if (activeFile === null || activeFile.extension !== "md") {
                new obsidian.Notice("The archiver works only in markdown (.md) files!");
                return;
            }
            const fileContents = yield this.app.vault.read(activeFile);
            const lines = fileContents.split("\n");
            const archiver = new Archiver(this.settings);
            const archiveResult = archiver.archiveTasks(lines);
            new obsidian.Notice(archiveResult.summary);
            this.app.vault.modify(activeFile, archiveResult.lines.join("\n"));
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            const getConfig = (key) => {
                return this.app.vault.getConfig(key);
            };
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData(), {
                indentationSettings: {
                    useTab: getConfig("useTab"),
                    tabSize: getConfig("tabSize"),
                },
            });
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class ArchiverSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", { text: "Obsidian Task Archiver Settings" });
        new obsidian.Setting(containerEl)
            .setName("Archive heading")
            .setDesc("A heading with this text will be used as an archive")
            .addText((textComponent) => {
            textComponent
                .setPlaceholder(this.plugin.settings.archiveHeading)
                .setValue(this.plugin.settings.archiveHeading)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.archiveHeading = value;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName("Use date trees")
            .setDesc("Add completed tasks under a link to the current week")
            .addToggle((toggleComponent) => toggleComponent
            .setValue(this.plugin.settings.useDateTree)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.useDateTree = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(containerEl)
            .setDisabled(!this.plugin.settings.useDateTree)
            .setName("Weekly note pattern")
            .then((setting) => {
            setting.addMomentFormat((momentFormat) => {
                setting.descEl.appendChild(createFragment((fragment) => {
                    fragment.appendText("For more syntax, refer to ");
                    fragment.createEl("a", {
                        text: "format reference",
                        href: "https://momentjs.com/docs/#/displaying/format/",
                    }, (a) => {
                        a.setAttr("target", "_blank");
                    });
                    fragment.createEl("br");
                    fragment.appendText("Your current syntax looks like this: ");
                    momentFormat.setSampleEl(fragment.createEl("b"));
                    fragment.createEl("br");
                }));
                momentFormat
                    .setDefaultFormat(this.plugin.settings.weeklyNoteFormat)
                    .setPlaceholder(this.plugin.settings.weeklyNoteFormat)
                    .setValue(this.plugin.settings.weeklyNoteFormat)
                    .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.weeklyNoteFormat = value;
                    yield this.plugin.saveSettings();
                }));
            });
        });
    }
}

module.exports = ObsidianTaskArchiver;
